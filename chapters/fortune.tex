\chapter{Description of Fortune's algorithm}

We are now ready to describe Fortune's algorithm. We start with describing an overview of the algorithm, and then in the next section we describe some of the details thoroughly -- so anytime the algorithm says ``see detail $n$'', then this detail can be found in the next section.

\begin{alg} \label{alg:fortune} \textsc{VoronoiDiagram}(P) \\
\textit{Input:} A set $P = \curly{p_1, \ldots, p_n}$ of point sites in the plane. \\
\textit{Output:} The Voronoi diagram $\Vor(P)$ given inside a bounding box in a doubly-connected edge list $\mathcal{D}$.
\begin{enumerate}
    \item Initialize the event queue $\mathcal{Q}$ with a site event for every point in $P$, initialize the beach line tree $\mathcal{T}$ to be \textsc{nil}, and let the DCEL $\mathcal{D}$ be empty.
    \item Repeat the following until $\mathcal{Q}$ is empty:
    \begin{enumerate}[i.]
        \item Remove the event $e$ with the largest $y$-coordinate from $\mathcal{Q}$.
        \item If $e$ is a site event call \textsc{HandleSiteEvent}$(e)$.
        \item If $e$ is a site event call \textsc{HandleCircleEvent}$(e)$.
    \end{enumerate}
    \item At this point the internal nodes in $\mathcal{T}$ represent the infinite edges of $\Vor(P)$. Compute a bounding box $B$ which contains all points in $P$, as well as all the vertices of $\Vor(P)$, which are contained in $\mathcal{D}$. Intersect the infinite edges in $\mathcal{T}$ with $B$ and let these intersection points be new vertices in $\mathcal{D}$. Add new edges and pointers to make sure we still have a proper DCEL structure.
\end{enumerate}
\end{alg}

\begin{proc} \textsc{HandleSiteEvent}$(e)$
\begin{enumerate}
    \item Let $p_i$ denote the site that $e$ points to.
    \item If $\mathcal{T} = \textsc{nil}$ then let $\mathcal{T}$ store the single arc that is described by $p_i$ and return.
    \item Otherwise, $\mathcal{T} \ne \textsc{nil}$. Search in $\mathcal{T}$ for the arc $\alpha$ vertically above $p_i$, that is the arc at which the vertical line through $p_i$ intersects the beach line. (See detail \#)
    \item If $\alpha$ has a pointer to a circle event $e'$, then remove $e'$ from $\mathcal{Q}$, as this circle event is now a false alarm since $\alpha$ is about to disappear earlier than we initially thought.
    \item Create the new arc $\beta$ defined by $p_i$ and insert it into $\mathcal{T}$ as described in Section \ref{sec:insertingatsiteevents}. Update $\mathcal{D}$ by creating the new half-edges which will be traced out by the two new breakpoints as described in Section \ref{sec:dcelatsiteevents}.
    \item Check the triple of consecutive arcs where the new arc for $p_i$ is the left arc to see if the breakpoints converge. If so, insert the circle event into $\mathcal{Q}$ and add pointers between the node in $\mathcal{T}$ and the node in $\mathcal{Q}$. Do the same for the triple where the new arc is the right arc. (See detail \#)
\end{enumerate}
\end{proc}

\begin{proc} \textsc{HandleCircleEvent}$(e)$
\begin{enumerate}
    \item Let $\alpha$ be the arc pointed to by $e$, which is about to disappear from the beach line.
    \item Delete all circle events from $\mathcal{Q}$ which involve $\alpha$: The one where $\alpha$ is the middle arc has already been deleted, and the other two possible circle events where $\alpha$ is the left and right arc respectively can be found through $\alpha$'s \textsf{.leftArc} and \textsf{.rightArc} pointers. (See detail \#)
    \item Delete $\alpha$ from $\mathcal{T}$, how this is done is described in Section \ref{sec:deletingatsiteevents}.
    \item Add the center $c$ of the circle describing $e$ as a new vertex of $\mathcal{D}$. Connect the half-edges in $\mathcal{D}$ that converge at $e$, and create a new half-edge which starts at $c$ and setup the appropriate pointers. The details are given in Section \ref{sec:dcelatcircleevents}.
    \item As $\alpha$ disappears from the beach line, we get new triples of consecutive arcs which might have converging breakpoints that can lead to a circle event. Check these and add circle events if needed. (See detail \#)
\end{enumerate}
\end{proc}

\section{Details}

\subsection*{Detail 1: Intersecting lines}
As a subroutine in several steps during the algorithm we will need to intersect line segments or rays with each other. We start by describing a solution to this in general. This detail assumes that the reader is familiar with basic linear algebra. We want to find the intersection between 2 lines. We parametrize the lines as follows:
\[
    \gamma_1(t) = p + t d_1 \quad \text{and} \quad
    \gamma_2(s) = q + s d_2,
\]
where $p$ and $q$ are points on the lines, and $d_1$ and $d_2$ are direction vectors which tells us which way the lines point. The situation is illustrated as follows:
\[
    \includegraphics[scale=0.8]{intersect_lines}
\]
To find an intersection point, we must find $s, t \in \R$ such that
\[
    \gamma_1(t) = \gamma_2(s).
\]
That is, we want to solve
\[
    p + t d_1 = q + s d_2.
\]
This can be rewritten into the matrix equation
\[
    A \begin{pmatrix}
        s \\
        -t
    \end{pmatrix}
    =
    q - p,
\]
where $A = \begin{pmatrix} \mid & \mid \\ d_1 & d_2 \\ \mid & \mid \end{pmatrix}$ is the matrix which has $d_1$ and $d_2$ as left and right columns, respectively. The equation system has a unique solution if $d_1$ and $d_2$ are linearly independent, and if they are, the solution is given by
\[
    \begin{pmatrix}
        s \\
        -t
    \end{pmatrix}
    =
    A^{-1} (q - p).
\]
This linear independence property is equivalent to checking that the determinant $\det(A)$ is non-zero. So, in order to check if two lines intersect, we first check if $\det(A) \ne 0$. If not, we say the lines don't intersect. Otherwise, they intersect, and we use the above solution to find the intersection point.

\subsection*{Detail 2: Choose breakpoint based on the ordering of tuple}
Let $p_i$ and $p_j$ be two sites and let $\beta_i$ and $\beta_j$ be the hyperbolas that they describe. If a breakpoint stores the tuple $(p_i, p_j)$ then we want a way to find the $x$ coordinate of that breakpoint. Since the intersection of two hyperbolas may contain 2 intersection points, we need to pick the correct one. We already described this when discussing internal tree nodes at the start of Section \ref{sec:bst}, but let's recap: The order is important since the intersection of the hyperbolas defined by $p_i$ and $p_j$ consists of two points, and the order lets us tell these breakpoints apart. If we consider the beach line as running from the left to the right, then at every breakpoint an arc is leaving, and another is entering it. Thus the tuple $(p_i, p_j)$ tells us that we are interested in the breakpoint at which an arc pointing to $p_i$ leaves, and an arc pointing to $p_j$ is entering the beach line. We will need the following result:

\begin{prop} \label{prop:highschool1}
Let $f(x) = a x^2 + b x + c$ be a polynomial with discriminant $D > 0$ with roots $r_1 < r_2$. Then $r = \tfrac{1}{2}(r_1 + r_2)$ is the only solution to $\displaystyle\frac{df}{dx}(r) = 0$ and the expressions $\displaystyle\frac{df}{dx}(r_1)$ and $\displaystyle\frac{df}{dx}(r_2)$ are non-zero and have opposite signs.
\end{prop}
This fact can be visualized as follows:
\[
    \includegraphics[scale=0.8]{polynomial_result}
\]
\begin{proof}[Proof of Proposition \ref{prop:highschool1}]
It is well-known that we may factor $f$ as follows:
\[
    f = a (x - r_1) (x - r_2) = a x^2 - a(r_1 + r_2) x + a r_1 r_2.
\]
Since two polynomials are equal if and only if their coefficients are equal we get $b = - a (r_1 + r_2)$, which gives us
\[
    \frac{df}{dx} (r) = 2 a r + b = 2 a \para{\frac{r_1 + r_2}{2}} - a (r_1 + r_2) = 0.
\]
This is the only solution since $\displaystyle\frac{df}{dx}$ is a first degree polynomial. Now note that $\displaystyle\frac{d^2 f}{d x^2}(x) = 2a \ne 0$ and $r_1 < r < r_2$ which gives us that
\[
    \text{sgn} \para{\frac{df}{dx}(r_1)} = -\text{sgn} \para{\frac{df}{dx}(r_2)} \ne 0.
\]
\end{proof}
When intersecting two of the paraboals of the beach line, we will find two intersection points, because of our assumptions. Proposition \ref{prop:highschool1} then gives us that at these intersection points $r_1, r_2$ we have that
\[
    \begin{cases}
        \displaystyle\frac{d(\beta_i - \beta_j)}{dx}(r_k) \ne 0 \text{ for } k = 1, 2 & \text{ }\vspace{0.25cm} \\ \text{sgn} \para{\displaystyle\frac{d(\beta_i - \beta_j)}{dx}(r_1)} = -\text{sgn} \para{\displaystyle\frac{d(\beta_i - \beta_j)}{dx}(r_2)} & \text{ }
    \end{cases}
\]
We then want to locate a specific breakpoint between two arcs, and the above will help us to do this.

To intersect the two parabolas $\beta_i$ and $\beta_j$ we write
\[
    (\beta_i - \beta_j)(x) = a x^2 + b x + c,
\]
where (for $p = p_i$, $q = p_j$, $h_p = p_y - \ell_y$ and $h_q = q_y - \ell_y$)
\begin{align*}
    a &= \frac{1}{2} \para{\frac{1}{h_p} - \frac{1}{h_q}}, \\
    b &= \frac{q_x}{h_q} - \frac{p_x}{h_p}, \\
    c &= \frac{q_y(p_x^2 + p_y^2) - p_y (q_x^2 + q_y^2) + \ell_y (q_x^2 + q_y^2 - p_x^2 - p_y^2) + \ell_y^2 (p_y - q_y)}{2 h_p h_q}.
\end{align*}
The square root of the discriminant is then
\[
    d = \sqrt{b^2 - 4 ac} = \sqrt{\frac{(p_x - q_x)^2 + (p_y - q_y)^2}{h_p h_q}}.
\]
The $x$-values of the intersection points are then given by the well-known formulas
\[
    r_1 = \frac{-b - d}{2 a}, \quad
    r_2 = \frac{-b + d}{2 a},
\]
which gives us the intersection points $q_1 = (r_1, \beta_i(r_1))$ and $q_2 = (r_2, \beta_i(r_2))$. Now, we want to find the breakpoint which at which an arc of $\beta_i$ exits the beach line, and an arc of $\beta_j$ enters the beach line. Proposition \ref{prop:highschool1} gives us a way of picking which one of $q_1$ and $q_2$ is the breakpoint that we need. For $\beta_i$ to exit and $\beta_j$ to enter, we need to pick $k$ such that
\[
    \frac{d \beta_i}{dx}(r_k) > \frac{d \beta_j}{dx}(r_k).
\]
\todo{Draw a figure with two arcs on the beach line, where we see one exiting and another entering, and draw the differentials.} Proposition \ref{prop:highschool1} garantuees that either
\begin{align*}
    \frac{d \beta_i}{dx}(r_1) > \frac{d \beta_j}{dx}(r_1) &\text{ and } \frac{d \beta_i}{dx}(r_2) < \frac{d \beta_j}{dx}(r_2) \\
    &\text{or} \\
    \frac{d \beta_i}{dx}(r_1) < \frac{d \beta_j}{dx}(r_1) &\text{ and } \frac{d \beta_i}{dx}(r_2) > \frac{d \beta_j}{dx}(r_2),
\end{align*}
so it is possible to make the right choice. Now, note that
\[
    \frac{d \beta_i}{dx}(r_k) > \frac{d \beta_j}{dx}(r_k)
\]
if and only if
\[
    (r_k - p_x) (q_y - \ell_y) > (r_k - q_x) (p_y - \ell_y).
\]
This gives us a criterion for deciding which intersection point describes the breakpoint in question.

\subsection*{Detail 3: How to find the arc vertically above a point}
\subsection*{Detail 4: How to check if two breakpoints are converging}
\[
    \includegraphics[scale=0.8]{ray_intersection}
\]

\subsection*{Detail 5: Finding a circle through 3 points}
As a part of the algorithm, we need to find the circle $C$ through 3 points $p_1, p_2, p_3$. It turns out if we intersect $\bi(p_1, p_2)$ and $\bi(p_2, p_3)$ we find the center of $C$, and then to find the radius we just need to find the distance from the center to one of the points. This is because if $x \in \bi(p_1, p_2) \cap \bi(p_2, p_3)$ then
\[
    \dist(x, p_1) = \dist(x, p_2) = \dist(x, p_3),
\]
so $x$ is exactly the center of a circle through $p_1, p_2, p_3$.

To intersect the bisectors, we form the midpoints
\[
    m_1 = \frac{1}{2}(p + q) \quad \text{and} \quad m_2 = \frac{1}{2}(q + r)
\]
and then we let $d_1$ and $d_2$ denote $q - p$ and $r - q$ rotated 90 degrees counterclockwise. Then $s \mapsto m_1 + s d_1$ and $t \mapsto m_2 + t d_2$ parametrize $\bi(p_1, p_2)$ and $\bi(p_2, p_3)$, respectively. To intersect $\bi(p_1, p_2)$ and $\bi(p_2, p_3)$ we then need to find $s, t \in \R$ such that
\[
    m_1 + s d_1 = m_2 + t d_2.
\]
This can be rewritten into the matrix equation
\[
    \begin{pmatrix}
        \mid & \mid \\
        d_1 & d_2 \\
        \mid & \mid
    \end{pmatrix} \begin{pmatrix}
        s \\
        -t
    \end{pmatrix}
    =
    m_2 - m_1,
\]
and if $d_1$ and $d_2$ are linearly independent then it has the unique solution
\[
    \begin{pmatrix}
        s \\
        -t
    \end{pmatrix}
    =
    \begin{pmatrix}
        \mid & \mid \\
        d_1 & d_2 \\
        \mid & \mid
    \end{pmatrix}^{-1} (m_2 - m_1).
\]
\[
    \includegraphics[scale=0.8]{circle_3_points}
\]

\subsection*{Detail 6: Deleting false alarms during a circle event}
\subsection*{Detail 7: Intersecting a bounding box with the in-progress DCEL to get the final DCEL}

\section{Correctness}
\begin{lem}
Algorithm \label{alg:fortune} can be implemented such that it runs in $\mathcal{O}(n \log n)$ time and uses $\mathcal{O}(n)$ storage.
\end{lem}
\begin{proof}
\todo{.}
\end{proof}